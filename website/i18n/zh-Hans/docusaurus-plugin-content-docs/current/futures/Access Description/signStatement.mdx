---
id: SignatureStatement
title: 签名说明
sidebar_label: 签名说明
sidebar_position: 4
---

#### 签名说明

> 注：`${?}` 或 `$?` 表示对变量的引用。

在生成签名 `signature` 时，需要使用申请 API Key 时获得的 `SECRET KEY` 对 `unencrypted_string` 进行加密。

---

#### 签名生成逻辑

##### 1️⃣ 若 HTTP 请求参数放在 **QueryString** 中：
```
unencrypted_string = ${fixed_header}#${end_point}#${query_string}
```

当 `query_string` 有多个键值对时，需要按照键的字典序（ASCII 升序）进行排序后拼接，如：
```
keya=value&keyb=value&keyc=value
```

##### 2️⃣ 若 HTTP 请求参数放在 **RequestBody** 中：
```
unencrypted_string = ${fixed_header}#${end_point}#${request_body}
```

---

#### 参数定义

| 参数 | 含义 |
|------|------|
| `fixed_header` | 固定头部参数字符串，由 appkey 与 timestamp 组成 |
| `end_point` | 请求路径（不包含域名） |
| `query_string` | 请求 URL 中的参数字符串 |
| `request_body` | POST 请求体内容 |

---

#### 结构说明

```
fixed_header = "validate-appkey=${your_appkey}&validate-timestamp=${current_timestamp}"
```

每个部分之间使用 `#` 符号拼接：
```
unencrypted_string = fixed_header#end_point#query_string
```

---

#### 示例

```bash
curl -G "https://fapi.xt.com/future/user/v1/balance/detail" \
  -H "validate-appkey: $APPKEY" \
  -H "validate-timestamp: $TIMESTAMP" \
  -H "validate-signature: $SIGNATURE" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "coin=btc"
```

**假设：**
```
当前时间戳为 *****
你的 APPKEY 为 ++++++
```

则：
```
fixed_header="validate-appkey=++++++&validate-timestamp=*****"
end_point="/future/user/v1/balance/detail"
query_string="coin=btc"
```

最终：
```
unencrypted_string="validate-appkey=++++++&validate-timestamp=*****#/future/user/v1/balance/detail#coin=btc"
```

---

#### 生成签名

获取 `unencrypted_string` 后，可使用 `SECRET KEY` 通过 HMAC-SHA256 算法生成签名：

```bash
SIGNATURE=$(echo -n "$unencrypted_string" | openssl dgst -sha256 -hmac "$SECRETKEY" | awk '{print $2}')
echo $SIGNATURE
```

生成后，将 `SIGNATURE` 填入 HTTP 请求头中的：
```
validate-signature: $SIGNATURE
```

---
